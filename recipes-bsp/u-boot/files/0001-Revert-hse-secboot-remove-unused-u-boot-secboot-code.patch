From 06737dfbb9e8171a0dcdede34b818e3e5d937983 Mon Sep 17 00:00:00 2001
From: Meng Li <meng.li@windriver.com>
Date: Mon, 12 Dec 2022 12:11:18 +0800
Subject: [PATCH 1/3] Revert "hse:secboot: remove unused u-boot secboot code"

This reverts commit fc931960b574f9019ee71a04145419474ccee1b8.

It still needs the secure boot enable command in u-boot command line for
Aptiv project. So, revert it back.

Upstream-Status: Inappropriate [Get it from NXP old SDK]

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 arch/arm/mach-s32/s32-cc/Makefile          |   1 +
 arch/arm/mach-s32/s32-cc/hse_adv_secboot.c | 635 +++++++++++++++++++++
 doc/README.nxp-hse-secboot                 |  91 +++
 drivers/crypto/fsl/Makefile                |   1 +
 drivers/crypto/fsl/hse/Makefile            |   5 +
 drivers/crypto/fsl/hse/hse_mmc.c           |  79 +++
 drivers/crypto/fsl/hse/hse_mu.c            | 236 ++++++++
 include/hse/hse_abi.h                      | 483 ++++++++++++++++
 include/hse/hse_mu.h                       |  20 +
 9 files changed, 1551 insertions(+)
 create mode 100644 arch/arm/mach-s32/s32-cc/hse_adv_secboot.c
 create mode 100644 doc/README.nxp-hse-secboot
 create mode 100644 drivers/crypto/fsl/hse/Makefile
 create mode 100644 drivers/crypto/fsl/hse/hse_mmc.c
 create mode 100644 drivers/crypto/fsl/hse/hse_mu.c
 create mode 100644 include/hse/hse_abi.h
 create mode 100644 include/hse/hse_mu.h

diff --git a/arch/arm/mach-s32/s32-cc/Makefile b/arch/arm/mach-s32/s32-cc/Makefile
index 188526ed..0ee639ab 100644
--- a/arch/arm/mach-s32/s32-cc/Makefile
+++ b/arch/arm/mach-s32/s32-cc/Makefile
@@ -9,6 +9,7 @@ obj-y += scmi_reset_agent.o
 obj-y += serdes_hwconfig.o
 obj-y += quick_boot_fixups.o
 obj-y += soc.o
+obj-$(CONFIG_HSE_SECBOOT)  += hse_adv_secboot.o
 obj-y += start_m7.o
 obj-$(CONFIG_MP)		+= mp.o
 obj-$(CONFIG_OF_LIBFDT)	+= fdt.o
diff --git a/arch/arm/mach-s32/s32-cc/hse_adv_secboot.c b/arch/arm/mach-s32/s32-cc/hse_adv_secboot.c
new file mode 100644
index 00000000..18d8768a
--- /dev/null
+++ b/arch/arm/mach-s32/s32-cc/hse_adv_secboot.c
@@ -0,0 +1,635 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * HSE advanced secure boot preparatory command demo
+ *
+ * Copyright 2020-2022 NXP
+ */
+
+#include <common.h>
+#include <command.h>
+#include <cpu_func.h>
+#include <errno.h>
+#include <fs.h>
+#include <malloc.h>
+#include <hse/hse_abi.h>
+#include <hse/hse_mu.h>
+
+#ifdef CONFIG_SD_BOOT
+DECLARE_GLOBAL_DATA_PTR;
+
+/* hse nvm key catalog configuration */
+#define HSE_NVM_KEY_CATALOG_CFG \
+{ HSE_ALL_MU_MASK, HSE_KEY_OWNER_CUST, \
+	HSE_KEY_TYPE_AES, 5U, HSE_KEY128_BITS }, \
+{ HSE_ALL_MU_MASK, HSE_KEY_OWNER_CUST, \
+	HSE_KEY_TYPE_AES, 10U, HSE_KEY256_BITS }, \
+{ HSE_ALL_MU_MASK, HSE_KEY_OWNER_CUST, \
+	HSE_KEY_TYPE_HMAC, 5U, HSE_KEY512_BITS }, \
+{ HSE_ALL_MU_MASK, HSE_KEY_OWNER_CUST, \
+	HSE_KEY_TYPE_ECC_PAIR, 2U, HSE_KEY256_BITS }, \
+{ HSE_ALL_MU_MASK, HSE_KEY_OWNER_CUST, \
+	HSE_KEY_TYPE_ECC_PUB, 2U, HSE_KEY256_BITS }, \
+{ HSE_ALL_MU_MASK, HSE_KEY_OWNER_CUST, \
+	HSE_KEY_TYPE_ECC_PUB_EXT, 1U, HSE_KEY256_BITS }, \
+{ HSE_ALL_MU_MASK, HSE_KEY_OWNER_CUST, \
+	HSE_KEY_TYPE_RSA_PAIR, 2U, HSE_KEY2048_BITS}, \
+{ HSE_ALL_MU_MASK, HSE_KEY_OWNER_CUST, \
+	HSE_KEY_TYPE_RSA_PUB, 2U, HSE_KEY2048_BITS}, \
+{ HSE_ALL_MU_MASK, HSE_KEY_OWNER_CUST, \
+	HSE_KEY_TYPE_RSA_PUB_EXT, 1U, HSE_KEY2048_BITS}, \
+{ 0U, 0U, 0U, 0U, 0U }
+
+/* hse ram key catalog configuration */
+#define  HSE_RAM_KEY_CATALOG_CFG \
+{HSE_ALL_MU_MASK, HSE_KEY_OWNER_ANY, \
+	HSE_KEY_TYPE_AES, 6u, HSE_KEY256_BITS }, \
+{HSE_ALL_MU_MASK, HSE_KEY_OWNER_ANY, \
+	HSE_KEY_TYPE_HMAC, 6u, HSE_KEY512_BITS}, \
+{HSE_ALL_MU_MASK, HSE_KEY_OWNER_ANY, \
+	HSE_KEY_TYPE_AES, 7u, HSE_KEY256_BITS }, \
+{HSE_ALL_MU_MASK, HSE_KEY_OWNER_ANY, \
+	HSE_KEY_TYPE_SHARED_SECRET, 1u, HSE_KEY256_BITS}, \
+{0u, 0u, 0u, 0u, 0u}
+
+#define APP_CODE_OFFSET 0x40
+
+#define UUID_BL2_CERT \
+	{ 0xea69e2d6, \
+	  0x635d, \
+	  0x11e4, \
+	  0x8d, 0x8c, \
+	 {0x9f, 0xba, 0xbe, 0x99, 0x56, 0xa5} }
+
+/* the nvm container used to format the hse key catalogs */
+static const struct hse_key_group_cfg_entry nvm_orig_cat[] = {
+	HSE_NVM_KEY_CATALOG_CFG
+};
+
+/* the ram container used to format the hse key catalogs */
+static const struct hse_key_group_cfg_entry ram_orig_cat[] = {
+	HSE_RAM_KEY_CATALOG_CFG
+};
+
+/* return 0 for equal uuids */
+static inline int compare_uuids(const struct uuid *uuid1,
+				const struct uuid *uuid2)
+{
+	return memcmp(uuid1, uuid2, sizeof(struct uuid));
+}
+
+static u32 get_fip_start(struct hse_private *priv)
+{
+	return priv->ivt.app_boot + APP_CODE_OFFSET;
+}
+
+static u64 get_fip_toc_offset(struct hse_private *priv, struct uuid *search)
+{
+	struct fip_toc_header *toc_header;
+	struct fip_toc_entry *toc_entry;
+	uintptr_t fip_hdr_start, fip_hdr_end;
+
+	fip_hdr_start = (uintptr_t)priv->app_boot_hdr.ram_load;
+	toc_header = (struct fip_toc_header *)fip_hdr_start;
+	toc_entry = (struct fip_toc_entry *)(toc_header + 1);
+
+	/* fip_hdr_end is at the start of the first entry */
+	fip_hdr_end = fip_hdr_start + (uintptr_t)toc_entry->offset;
+
+	while ((uintptr_t)toc_entry < fip_hdr_end) {
+		if (!compare_uuids(&toc_entry->uuid, search))
+			return toc_entry->offset;
+		toc_entry++;
+	}
+
+	return 0;
+}
+
+static u64 get_fip_size(struct hse_private *priv)
+{
+	struct uuid uuid_null = { 0 };
+
+	return get_fip_toc_offset(priv, &uuid_null);
+}
+
+static u64 get_fip_sign_offset(struct hse_private *priv)
+{
+	struct uuid uuid_bl2_cert = UUID_BL2_CERT;
+
+	return get_fip_toc_offset(priv, &uuid_bl2_cert);
+}
+
+static u32 get_fip_sign_mmc(struct hse_private *priv)
+{
+	u32 sign_offset;
+
+	sign_offset = (u32)get_fip_sign_offset(priv);
+	if (!sign_offset)
+		return 0;
+
+	return get_fip_start(priv) + sign_offset;
+}
+
+static uintptr_t get_fip_sign_sram(struct hse_private *priv)
+{
+	uintptr_t fip_hdr_start = (uintptr_t)priv->app_boot_hdr.ram_load;
+	uintptr_t sign_offset;
+
+	sign_offset = (uintptr_t)get_fip_sign_offset(priv);
+	if (!sign_offset)
+		return 0;
+
+	return fip_hdr_start + sign_offset;
+}
+
+int hse_format_key_store(struct hse_private *priv, u32 *recv_buf)
+{
+	int ret = 0;
+
+	printf("\tFormatting NVM and RAM key stores...\n");
+	memset((void *)&priv->srv_desc, 0, sizeof(struct hse_srv_desc));
+
+	memcpy((void *)&priv->nvm_catalog, (void *)&nvm_orig_cat,
+	       sizeof(nvm_orig_cat));
+	memcpy((void *)&priv->ram_catalog, (void *)&ram_orig_cat,
+	       sizeof(ram_orig_cat));
+
+	priv->srv_desc.srv_id = HSE_SRV_ID_FORMAT_KEY_CATALOGS;
+	priv->srv_desc.format_catalogs_req.nvm_key_catalog_cfg_addr =
+			(uintptr_t)&priv->nvm_catalog;
+	priv->srv_desc.format_catalogs_req.ram_key_catalog_cfg_addr =
+			(uintptr_t)&priv->ram_catalog;
+
+	flush_dcache_range((u64)priv,
+			   (u64)priv + sizeof(struct hse_private));
+
+	ret = hse_send_recv(HSE_CHANNEL_GENERAL,
+			   (u32)(uintptr_t)&priv->srv_desc,
+			   recv_buf);
+	if (ret) {
+		printf("ERROR: key catalog format failed!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int hse_import_key(struct hse_private *priv, u32 *recv_buf)
+{
+	struct hse_key_info *key_info;
+	struct hse_import_key_srv *import_key_req;
+	int ret;
+
+	key_info = &(priv->key_info);
+	import_key_req = &(priv->srv_desc.import_key_req);
+
+	printf("\tImporting RSA public key into NVM key store...\n");
+	memset((void *)&priv->key_info, 0, sizeof(struct hse_key_info));
+	memset((void *)&priv->srv_desc, 0, sizeof(struct hse_srv_desc));
+
+	key_info->key_flags = HSE_KF_USAGE_VERIFY;
+	key_info->key_bit_len =	BYTES_TO_BITS(ARRAY_SIZE(priv->rsa_modulus));
+	key_info->key_counter = 0ul;
+	key_info->smr_flags = 0ul;
+	key_info->key_type = HSE_KEY_TYPE_RSA_PUB;
+	key_info->pub_exponent_size = ARRAY_SIZE(priv->rsa_exponent);
+
+	priv->srv_desc.srv_id = HSE_SRV_ID_IMPORT_KEY;
+	import_key_req->key_handle = HSE_BOOT_KEY_HANDLE;
+	import_key_req->key_info_addr = (uintptr_t)key_info;
+	import_key_req->key_addr[0] = (uintptr_t)priv->rsa_modulus;
+	import_key_req->key_addr[1] = (uintptr_t)priv->rsa_exponent;
+	import_key_req->key_addr[2] = 0u;
+	import_key_req->key_len[0] = ARRAY_SIZE(priv->rsa_modulus);
+	import_key_req->key_len[1] = ARRAY_SIZE(priv->rsa_exponent);
+	import_key_req->key_len[2] = 0u;
+	import_key_req->cipher_key = HSE_INVALID_KEY_HANDLE;
+	import_key_req->auth_key = HSE_INVALID_KEY_HANDLE;
+
+	flush_dcache_range((u64)priv,
+			   (u64)priv + sizeof(struct hse_private));
+
+	ret = hse_send_recv(HSE_CHANNEL_GENERAL,
+			    (u32)(uintptr_t)&priv->srv_desc,
+			    recv_buf);
+	if (ret) {
+		printf("ERROR: rsa public key import failed!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int hse_install_cr_entry(struct hse_private *priv, u32 *recv_buf)
+{
+	int ret;
+
+	printf("\tGenerating Core Reset Entry...\n");
+	memset((void *)&priv->cr_entry, 0, sizeof(struct hse_cr_entry));
+	memset((void *)&priv->srv_desc, 0, sizeof(struct hse_srv_desc));
+
+	priv->cr_entry.core_id = HSE_APP_CORE3;
+	priv->cr_entry.cr_sanction = HSE_CR_SANCTION_KEEP_CORE_IN_RESET;
+	priv->cr_entry.preboot_smr_map = HSE_SMR_ENTRY_1;
+	priv->cr_entry.pass_reset = priv->app_boot_hdr.ram_entry;
+	priv->cr_entry.start_option = HSE_CR_AUTO_START;
+
+	priv->srv_desc.srv_id = HSE_SRV_ID_CORE_RESET_ENTRY_INSTALL;
+	priv->srv_desc.cr_install_req.cr_entry_index = 1u;
+	priv->srv_desc.cr_install_req.cr_entry_addr =
+					(uintptr_t)&priv->cr_entry;
+
+	flush_dcache_range((u64)priv,
+			   (u64)priv + sizeof(struct hse_private));
+
+	ret = hse_send_recv(HSE_CHANNEL_GENERAL,
+			    (u32)(uintptr_t)&priv->srv_desc,
+			    recv_buf);
+	if (ret) {
+		printf("ERROR: core reset entry install failed!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int hse_install_smr_entry(struct hse_private *priv, u32 *recv_buf)
+{
+	struct hse_smr_entry *smr_entry;
+	struct hse_smr_install_srv *smr_install_req;
+	u32 fip_size;
+	int ret;
+
+	smr_entry = &(priv->smr_entry);
+	smr_install_req = &(priv->srv_desc.smr_install_req);
+
+	printf("\tGenerating Secure Memory Region entry...\n");
+	memset((void *)&priv->smr_entry, 0, sizeof(struct hse_smr_entry));
+	memset((void *)&priv->srv_desc, 0, sizeof(struct hse_srv_desc));
+
+	/* need to recopy FIP to pass verification */
+	memset((void *)(uintptr_t)priv->app_boot_hdr.ram_load - APP_CODE_OFFSET, 0,
+	       priv->app_boot_hdr.code_len + APP_CODE_OFFSET);
+	hse_mmc_read((void *)(uintptr_t)priv->app_boot_hdr.ram_load - APP_CODE_OFFSET,
+		     priv->ivt.app_boot / 512,
+		     (priv->app_boot_hdr.code_len / 512) + 1);
+
+	fip_size = get_fip_size(priv);
+	if (!fip_size) {
+		printf("ERROR: invalid FIP size!\n");
+		return -ENOMEM;
+	}
+
+	/**
+	 * no address of actual code start, need to reference app bl header
+	 * fip start is at app_bl_header + 0x40
+	 */
+	smr_entry->smr_src = priv->ivt.app_boot + APP_CODE_OFFSET;
+	smr_entry->smr_dst_addr = priv->app_boot_hdr.ram_load;
+	smr_entry->smr_size = fip_size - HSE_FIP_AUTH_LEN;
+	smr_entry->config_flags = (HSE_SMR_CFG_FLAG_SD_FLASH |
+				   HSE_SMR_CFG_FLAG_INSTALL_AUTH);
+	smr_entry->check_period = 0;
+	smr_entry->key_handle = HSE_BOOT_KEY_HANDLE;
+	smr_entry->sign_sch.sign_scheme = HSE_SIGN_RSASSA_PKCS1_V15;
+	smr_entry->sign_sch.sch.hash_algo = HSE_HASH_ALGO_SHA_1;
+	smr_entry->auth_tag = get_fip_sign_mmc(priv);
+	smr_entry->decrypt_key_handle = HSE_SMR_DECRYPT_KEY_HANDLE_NOT_USED;
+	smr_entry->version_offset = 0;
+
+	priv->srv_desc.srv_id = HSE_SRV_ID_SMR_ENTRY_INSTALL;
+	smr_install_req->access_mode = HSE_ACCESS_MODE_ONE_PASS;
+	smr_install_req->entry_index = 1u;
+	smr_install_req->smr_entry_addr = (uintptr_t)smr_entry;
+	smr_install_req->smr_data_addr = priv->app_boot_hdr.ram_load;
+	smr_install_req->smr_data_len = fip_size - HSE_FIP_AUTH_LEN;
+	smr_install_req->smr_auth_tag_addr = (uintptr_t)priv->fip_signature;
+	smr_install_req->smr_auth_tag_len = HSE_FIP_AUTH_LEN;
+
+	flush_dcache_range((u64)priv,
+			   (u64)priv + sizeof(struct hse_private));
+
+	ret = hse_send_recv(HSE_CHANNEL_GENERAL,
+			    (u32)(uintptr_t)&priv->srv_desc,
+			    recv_buf);
+	if (ret) {
+		printf("ERROR: smr entry install failed!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int hse_generate_sys_img(struct hse_private *priv, u32 *recv_buf)
+{
+	struct hse_publish_sys_img_srv *publish_sys_img_req;
+	int ret;
+
+	publish_sys_img_req = &(priv->srv_desc.publish_sys_img_req);
+
+	printf("\tGenerating SYS_IMG...\n");
+	memset((void *)priv->sys_img, 0, HSE_SYS_IMG_MAX_SIZE);
+	memset((void *)&priv->srv_desc, 0, sizeof(struct hse_srv_desc));
+
+	priv->sys_img_len = HSE_SYS_IMG_MAX_SIZE;
+	priv->srv_desc.srv_id = HSE_SRV_ID_PUBLISH_SYS_IMAGE;
+	publish_sys_img_req->publish_options = HSE_PUBLISH_ALL_DATA_SETS;
+	publish_sys_img_req->publish_offset_addr = 
+		(uintptr_t)&priv->publish_offset;
+	publish_sys_img_req->buff_length_addr = (uintptr_t)&priv->sys_img_len;
+	publish_sys_img_req->buff_addr = (uintptr_t)priv->sys_img;
+
+	flush_dcache_range((u64)priv,
+			   (u64)priv + sizeof(struct hse_private));
+
+	ret = hse_send_recv(HSE_CHANNEL_ADMIN,
+			    (u32)(uintptr_t)&priv->srv_desc,
+			    recv_buf);
+	if (ret) {
+		printf("ERROR: sys-img generation failed!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int hse_write_sys_img(struct hse_private *priv, bool secure)
+{
+	int ret;
+	u32 sys_img_blk, sys_img_num_blks;
+
+	printf("\tPublishing SYS_IMG...\n");
+
+	flush_dcache_range((u64)priv,
+			   (u64)priv + sizeof(struct hse_private));
+
+	sys_img_blk = priv->ivt.sys_img / 512;
+	sys_img_num_blks = HSE_SYS_IMG_MAX_SIZE / 512;
+
+	ret = hse_mmc_write(&priv->sys_img, sys_img_blk, sys_img_num_blks);
+	if (ret) {
+		printf("ERROR: sys-img publish failed!\n");
+		return ret;
+	}
+
+	/* external flash type, flash page size */
+	priv->ivt.sys_img_ext_flash_type = HSE_EXT_FLASH_SD;
+	priv->ivt.sys_img_flash_page_size = HSE_EXT_FLASH_PAGE;
+
+	/* set BOOT_SEQ bit, if using secure boot */
+	if (secure)
+		priv->ivt.boot_cfg |= HSE_IVT_BOOTSEQ_BIT;
+
+	/* write ivt */
+	ret = hse_mmc_write(&priv->ivt, HSE_IVT_BLK, 1);
+	if (ret) {
+		printf("ERROR: ivt write failed!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int hse_enable_mus(struct hse_private *priv, u32 *recv_buf)
+{
+	struct hse_getset_attr_srv *getset_attr_req;
+	int ret;
+
+	printf("\tEnabling MUs...\n");
+
+	getset_attr_req = &(priv->srv_desc.getset_attr_req);
+
+	priv->srv_desc.srv_id = HSE_SRV_ID_SET_ATTR;
+
+	priv->mu_config.mu_instances[0].mu_config = HSE_MU_ACTIVATED;
+	priv->mu_config.mu_instances[0].xrdc_domain_id = 0u;
+	priv->mu_config.mu_instances[0].shared_mem_chunk_size = 0u;
+
+	priv->mu_config.mu_instances[1].mu_config = HSE_MU_ACTIVATED;
+	priv->mu_config.mu_instances[1].xrdc_domain_id = 0u;
+	priv->mu_config.mu_instances[1].shared_mem_chunk_size = 0u;
+
+	priv->mu_config.mu_instances[2].mu_config = HSE_MU_ACTIVATED;
+	priv->mu_config.mu_instances[2].xrdc_domain_id = 0u;
+	priv->mu_config.mu_instances[2].shared_mem_chunk_size = 0u;
+
+	priv->mu_config.mu_instances[3].mu_config = HSE_MU_ACTIVATED;
+	priv->mu_config.mu_instances[3].xrdc_domain_id = 0u;
+	priv->mu_config.mu_instances[3].shared_mem_chunk_size = 0u;
+
+	getset_attr_req->attr_id = HSE_MU_CONFIG_ATTR_ID;
+	getset_attr_req->attr_len = sizeof(struct hse_mu_config);
+	getset_attr_req->p_attr = (uintptr_t)&priv->mu_config;
+
+	flush_dcache_range((u64)priv,
+			   (u64)priv + sizeof(struct hse_private));
+
+	ret = hse_send_recv(HSE_CHANNEL_ADMIN,
+			    (u32)(uintptr_t)&priv->srv_desc,
+			    recv_buf);
+	if (ret) {
+		printf("ERROR: enable MU failed!\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int do_hse_secboot_enable(cmd_tbl_t *cmdtp, int flag,
+				 int argc, char * const argv[])
+{
+	struct hse_private *priv;
+	char *pubkey_file;
+	char mmcdevpart[4];
+	u16 hse_status_ret;
+	u32 hse_recv;
+	u64 hse_resmem;
+	long long len_read;
+	int hse_nodeoffset, ret;
+	uintptr_t fip_sign_sram;
+
+	/* check if hse has been initialised */
+	hse_status_ret = hse_mu_check_status();
+	if (!(hse_status_ret & HSE_STATUS_INIT_OK)) {
+		printf("ERROR: HSE not initialised or missing firmware!\n");
+		return CMD_RET_FAILURE;
+	}
+
+	if (argc < 2 || !argv[1]) {
+		printf("USAGE: hse_secboot_enable <public_key_file>.der\n");
+		printf("\n");
+		printf("    <public_key_file>.der - rsa public key in DER format\n");
+		printf("                            in the FAT partition\n");
+		return CMD_RET_FAILURE;
+	}
+	pubkey_file = argv[1];
+
+	/* find mem reserved for hse */
+	hse_nodeoffset = fdt_node_offset_by_compatible(gd->fdt_blob, -1,
+						       "nxp,s32cc-hse-rmem");
+	if (hse_nodeoffset < 0) {
+		printf("ERROR: hse_reserved node not found!\n");
+		return hse_nodeoffset;
+	}
+
+	hse_resmem = fdt_get_base_address(gd->fdt_blob, hse_nodeoffset);
+	if (hse_resmem < 0) {
+		printf("ERROR: could not get base address of hse_reserved node!\n");
+		return hse_resmem;
+	}
+
+	priv = (struct hse_private *)hse_resmem;
+	memset((void *)priv, 0, sizeof(struct hse_private));
+
+	/* read ivt block */
+	ret = hse_mmc_read((void *)&priv->ivt, HSE_IVT_BLK, 1);
+	if (ret) {
+		printf("ERROR: ivt read failed!\n");
+		return ret;
+	}
+
+	/* read app boot code header */
+	ret = hse_mmc_read((void *)&priv->app_boot_hdr,
+			   (priv->ivt.app_boot / 512), 1);
+	if (ret) {
+		printf("ERROR: app boot code header read failed!\n");
+		return ret;
+	}
+
+	fip_sign_sram = get_fip_sign_sram(priv);
+	if (!fip_sign_sram) {
+		printf("ERROR: FIP signature read failed!\n");
+		return -ENOMEM;
+	}
+	memcpy((void *)priv->fip_signature, (void *)fip_sign_sram, HSE_FIP_AUTH_LEN);
+
+	/* read public key file */
+	snprintf(mmcdevpart, sizeof(mmcdevpart), "%s:%s",
+		 env_get("mmcdev"), env_get("mmcpart"));
+	ret = fs_set_blk_dev("mmc", mmcdevpart, FS_TYPE_FAT);
+	if (ret) {
+		printf("ERROR: could not set block device!\n");
+		return ret;
+	}
+	ret = fs_read(pubkey_file, (uintptr_t)priv->rsa_pubkey, 0, 0, &len_read);
+	if (ret < 0) {
+		printf("ERROR: could not read public key file!\n");
+		return ret;
+	}
+
+	memcpy(priv->rsa_modulus,
+	       (priv->rsa_pubkey + MODULUS_OFFSET),
+	       MODULUS_SIZE);
+	memcpy(priv->rsa_exponent,
+	       (priv->rsa_pubkey + EXPONENT_OFFSET),
+	       EXPONENT_SIZE);
+
+	ret = hse_enable_mus(priv, &hse_recv);
+	if (ret)
+		return ret;
+
+	/* check if sys_img already exists */
+	if (!(hse_status_ret & HSE_STATUS_PRIMARY_SYSIMG)) {
+		printf("\tNo SYS_IMG, formatting key store...\n");
+
+		ret = hse_format_key_store(priv, &hse_recv);
+		if (ret)
+			return ret;
+	}
+
+	ret = hse_import_key(priv, &hse_recv);
+	if (ret)
+		return ret;
+
+	ret = hse_install_smr_entry(priv, &hse_recv);
+	if (ret)
+		return ret;
+
+	ret = hse_install_cr_entry(priv, &hse_recv);
+	if (ret)
+		return ret;
+
+	ret = hse_generate_sys_img(priv, &hse_recv);
+	if (ret) 
+		return ret;
+
+	ret = hse_write_sys_img(priv, true);
+	if (ret) 
+		return ret;
+
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(hse_secboot_enable, 2, 0, do_hse_secboot_enable,
+	   "generate device-specific SYS_IMG",
+	   "Generate SYS-IMG and place it on SD card");
+
+static int do_hse_keystore_format(cmd_tbl_t *cmdtp, int flag,
+				  int argc, char * const argv[])
+{
+	struct hse_private *priv;
+	u16 hse_status_ret;
+	u32 hse_recv;
+	u64 hse_resmem;
+	int hse_nodeoffset, ret;
+
+	/* check if hse has been initialised */
+	hse_status_ret = hse_mu_check_status();
+	if (!(hse_status_ret & HSE_STATUS_INIT_OK)) {
+		printf("ERROR: HSE not initialised or missing firmware!\n");
+		return CMD_RET_FAILURE;
+	}
+
+	/* check if sys_img already exists */
+	if (hse_status_ret & HSE_STATUS_PRIMARY_SYSIMG) {
+		printf("CHECK: SYS_IMG already loaded\n");
+		return CMD_RET_SUCCESS;
+	}
+
+	/* find mem reserved for hse */
+	hse_nodeoffset = fdt_node_offset_by_compatible(gd->fdt_blob, -1,
+						       "nxp,s32cc-hse-rmem");
+	if (hse_nodeoffset < 0) {
+		printf("ERROR: hse_reserved node not found! ERRNO: %d\n", hse_nodeoffset);
+		return hse_nodeoffset;
+	}
+
+	hse_resmem = fdt_get_base_address(gd->fdt_blob, hse_nodeoffset);
+	if (hse_resmem < 0) {
+		printf("ERROR: could not get base address of hse_reserved node!\n");
+		return hse_resmem;
+	}
+
+	priv = (struct hse_private *)hse_resmem;
+	memset((void *)priv, 0, sizeof(struct hse_private));
+
+	/* read ivt */
+	ret = hse_mmc_read((void *)&priv->ivt, HSE_IVT_BLK, 1);
+	if (ret) {
+		printf("ERROR: ivt read failed!\n");
+		return ret;
+	}
+
+	ret = hse_enable_mus(priv, &hse_recv);
+	if (ret)
+		return ret;
+
+	ret = hse_format_key_store(priv, &hse_recv);
+	if (ret)
+		return ret;
+
+	ret = hse_generate_sys_img(priv, &hse_recv);
+	if (ret)
+		return ret;
+
+	ret = hse_write_sys_img(priv, false);
+	if (ret)
+		return ret;
+
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(hse_keystore_format, 1, 0, do_hse_keystore_format,
+	   "format the keystore",
+	   "Format keystore for use in Linux kernel driver");
+
+#endif /* CONFIG_SD_BOOT */
diff --git a/doc/README.nxp-hse-secboot b/doc/README.nxp-hse-secboot
new file mode 100644
index 00000000..b44ad4ef
--- /dev/null
+++ b/doc/README.nxp-hse-secboot
@@ -0,0 +1,91 @@
+About
+-----
+
+NXP's HSE provides Advanced Secure Boot (ASB), which uses
+Secure Memory Regions (SMR) and a device-specific key.
+
+The demo application in hse_adv_secboot.c is provided as a U-Boot command.
+The demo application demonstrates secure booting from an SD card,
+on the S32gen1 boards.
+
+Prerequisites
+-------------
+
+HSE FW must be on the SD card to be able to use the demo applications.
+
+HSE is a separate NXP product, available through Flexera. To find out
+how to obtain HSE, please address our marketing department.
+
+Building U-Boot with HSE secure boot support
+--------------------------------------------
+
+The follow config options must be set:
+
+    CONFIG_NXP_S32CC="y"
+    CONFIG_HSE_SECBOOT="y" (depends on CONFIG_NXP_S32CC)
+    CONFIG_CMD_HSE_ADVANCED_SECBOOT="y" (depends on CONFIG_HSE_SECBOOT)
+
+Preparing U-Boot for secure booting
+-----------------------------------
+
+The script "tools/s32gen1_secboot.sh" is provided to easily configure
+and sign U-Boot for secure booting.
+
+Please note that, for the moment, the script uses a fixed key pair,
+stored in clear in the script. Support for user-generated RSA key
+pairs will be added in BSP26.
+
+The following steps are taken by the script to configure, sign and
+write the signed U-Boot image to the SD card:
+
+    1. Generate a RSA2048 key pair;
+    2. Extract application code and application header from u-boot.s32;
+    3. Pad extracted image to 1M;
+    4. Sign the extracted image with the generated private key;
+    5. Verify the signed image with the generated public key;
+    6. Write IVT to SD card;
+    7. Write HSE FW to SD card;
+    8. Write signature to SD card;
+    9. Write DCD to SD card;
+    10. Write signed and padded image to SD card.
+
+The following SD card layout is used for secure boot:
+
+-------------  0x0
+|    IVT    |
+-------------  0x100
+|    MBR    |
+-------------  0x200
+|  HSE FW   |
+-------------  0x70200
+|  SYS_IMG  |
+-------------  0x80200
+| SIGNATURE |
+-------------  0x80400
+|   U-Boot  |
+-------------  0x180400
+
+Booting in secure boot
+----------------------
+
+To activate secure boot, we first need to generate a SYS-IMG file for HSE, which
+will be signed with a device-specific key. Fortunately, this is handled by HSE
+itself, and is taken care of by the ASB demo application. Boot the board, and
+run the following in the U-Boot command line:
+
+	hse_adv_secboot_prep_demo
+
+After the command has run, you can reboot the board and it will boot securely. You
+can check by verifying the secure boot bit in the IVT:
+
+00000020: 0024 0800 0000 0000 0900 0000 0000 0000
+
+Turning off secure boot
+-----------------------
+
+To stop booting securely, the IVT must be rewritten and the SYS-IMG on the SD card
+must be deleted. The secure boot SD layout need not be kept, so this can easily be
+done by overwriting the data on the SD card, though it is suggested to zero out the
+area needed before hand.
+
+	dd if=u-boot/u-boot.s32 of=/dev/sdb bs=512 conv=notrunc,fsync
diff --git a/drivers/crypto/fsl/Makefile b/drivers/crypto/fsl/Makefile
index f9c3ccec..372c6691 100644
--- a/drivers/crypto/fsl/Makefile
+++ b/drivers/crypto/fsl/Makefile
@@ -8,3 +8,4 @@ obj-$(CONFIG_CMD_BLOB)$(CONFIG_IMX_CAAM_DEK_ENCAP) += fsl_blob.o
 obj-$(CONFIG_RSA_FREESCALE_EXP) += fsl_rsa.o
 obj-$(CONFIG_FSL_CAAM_RNG) += rng.o
 obj-$(CONFIG_FSL_MFGPROT) += fsl_mfgprot.o
+obj-$(CONFIG_HSE_SECBOOT) += hse/
diff --git a/drivers/crypto/fsl/hse/Makefile b/drivers/crypto/fsl/hse/Makefile
new file mode 100644
index 00000000..175a526c
--- /dev/null
+++ b/drivers/crypto/fsl/hse/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: BSD-3-Clause
+#
+# Copyright 2020 NXP
+
+obj-$(CONFIG_HSE_SECBOOT) += hse_mu.o hse_mmc.o
diff --git a/drivers/crypto/fsl/hse/hse_mmc.c b/drivers/crypto/fsl/hse/hse_mmc.c
new file mode 100644
index 00000000..b2bc923e
--- /dev/null
+++ b/drivers/crypto/fsl/hse/hse_mmc.c
@@ -0,0 +1,79 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * HSE ABI for secure boot in u-boot
+ *
+ * Copyright 2020 NXP
+ */
+
+#include <hse/hse_abi.h>
+
+/* see include/mmc.h and cmd/mmc.c */
+static int curr_device;
+
+struct mmc *hse_init_mmc_device(int dev, bool force_init)
+{
+	struct mmc *mmc;
+
+	mmc = find_mmc_device(dev);
+
+	if (!mmc) {
+		log_err("ERROR: no mmc device at slot %x!\n", dev);
+		return NULL;
+	}
+
+	if (force_init)
+		mmc->has_init = 0;
+
+	if (mmc_init(mmc))
+		return NULL;
+
+	return mmc;
+}
+
+int hse_mmc_read(void *addr, u32 blk, u32 cnt)
+{
+	struct mmc *mmc;
+	u32 n;
+
+	curr_device = 0;
+
+	mmc = hse_init_mmc_device(curr_device, false);
+	if (!mmc) {
+		log_err("ERROR: MMC init failed!\n");
+		return CMD_RET_FAILURE;
+	}
+
+	printf("\tMMC read: dev # %d, block # %d, count %d ...",
+	       curr_device, blk, cnt);
+
+	n = blk_dread(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	printf("%d blocks read: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+
+	return (n == cnt) ? 0 : -1;
+}
+
+int hse_mmc_write(void *addr, u32 blk, u32 cnt)
+{
+	struct mmc *mmc;
+	u32 n;
+
+	mmc = hse_init_mmc_device(curr_device, false);
+	if (!mmc) {
+		log_err("ERROR: MMC init failed!\n");
+		return -1;
+	}
+
+	printf("\tMMC write: dev # %d, block # %d, count %d...",
+	       curr_device, blk, cnt);
+
+	if (mmc_getwp(mmc) == 1) {
+		log_err("ERROR: card is write protected!\n");
+		return -1;
+	}
+
+	n = blk_dwrite(mmc_get_blk_desc(mmc), blk, cnt, addr);
+	printf("%d blocks written: %s\n", n, (n == cnt) ? "OK" : "ERROR");
+
+	return (n == cnt) ? 0 : -1;
+}
+
diff --git a/drivers/crypto/fsl/hse/hse_mu.c b/drivers/crypto/fsl/hse/hse_mu.c
new file mode 100644
index 00000000..87196a16
--- /dev/null
+++ b/drivers/crypto/fsl/hse/hse_mu.c
@@ -0,0 +1,236 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * HSE MU interface for secure boot in u-boot
+ *
+ * Copyright 2020-2021 NXP
+ */
+
+#include <common.h>
+#include <linux/io.h>
+#include <errno.h>
+
+#include <hse/hse_mu.h>
+#include <hse/hse_abi.h>
+
+#define MU0B_BASE    0x40210000ul
+#define MU1B_BASE    0x40211000ul
+#define MU2B_BASE    0x40212000ul
+#define MU3B_BASE    0x40213000ul
+
+#define HSE_STATUS_MASK     0xFFFF0000ul /* HSE global status FSR mask */
+
+/**
+ * hse_err_decode - HSE Error Code Translation
+ * @srv_rsp: HSE service response
+ *
+ * Return: 0 on service request success, error code otherwise
+ */
+static inline int hse_err_decode(u32 *srv_rsp)
+{
+	switch (*srv_rsp) {
+	case HSE_SRV_RSP_OK:
+		return CMD_RET_SUCCESS;
+	case HSE_SRV_RSP_VERIFY_FAILED:
+		printf("ERROR: auth tag/signature verification failed!\n");
+		goto ret_err;
+	case HSE_SRV_RSP_INVALID_ADDR:
+		printf("ERROR: invalid service descriptor address!\n");
+		goto ret_err;
+	case HSE_SRV_RSP_INVALID_PARAM:
+		printf("ERROR: invalid service descriptor parameter!\n");
+		goto ret_err;
+	case HSE_SRV_RSP_KEY_INVALID:
+		printf("ERROR: key flags do not match requested operation!\n");
+		goto ret_err;
+	case HSE_SRV_RSP_NOT_ALLOWED:
+		printf("ERROR: operation not allowed!\n");
+		goto ret_err;
+	default:
+		printf("ERROR: unknown error, EFAULT!\n");
+		goto ret_err;
+	}
+ret_err:
+	return CMD_RET_FAILURE;
+}
+
+/**
+ * struct hse_mu_regs - HSE Messaging Unit Registers
+ * @ver: Version ID Register, offset 0x0
+ * @par: Parameter Register, offset 0x4
+ * @cr: Control Register, offset 0x8
+ * @sr: Status Register, offset 0xC
+ * @fcr: Flag Control Register, offset 0x100
+ * @fsr: Flag Status Register, offset 0x104
+ * @gier: General Interrupt Enable Register, offset 0x110
+ * @gcr: General Control Register, offset 0x114
+ * @gsr: General Status Register, offset 0x118
+ * @tcr: Transmit Control Register, offset 0x120
+ * @tsr: Transmit Status Register, offset 0x124
+ * @rcr: Receive Control Register, offset 0x128
+ * @rsr: Receive Status Register, offset 0x12C
+ * @tr[n]: Transmit Register n, offset 0x200 + 4*n
+ * @rr[n]: Receive Register n, offset 0x280 + 4*n
+ */
+struct hse_mu_regs {
+	const u32 ver;
+	const u32 par;
+	u32 cr;
+	u32 sr;
+	u8 reserved0[240]; /* 0xF0 */
+	u32 fcr;
+	const u32 fsr;
+	u8 reserved1[8]; /* 0x8 */
+	u32 gier;
+	u32 gcr;
+	u32 gsr;
+	u8 reserved2[4]; /* 0x4 */
+	u32 tcr;
+	const u32 tsr;
+	u32 rcr;
+	const u32 rsr;
+	u8 reserved3[208]; /* 0xD0 */
+	u32 tr[16];
+	u8 reserved4[64]; /* 0x40 */
+	const u32 rr[16];
+};
+
+static struct hse_mu_regs * const regs = (struct hse_mu_regs *)MU0B_BASE;
+
+/**
+ * hse_mu_check_status - check the HSE global status
+ *
+ * Return: 16 MSB of MU instance FSR
+ */
+u16 hse_mu_check_status(void)
+{
+	u32 fsrval;
+
+	fsrval = ioread32(&regs->fsr);
+	fsrval = (fsrval & HSE_STATUS_MASK) >> 16u;
+
+	return (u16)fsrval;
+}
+
+/**
+ * hse_mu_channel_available - check service channel status
+ * @channel: channel index
+ *
+ * The 16 LSB of MU instance FSR are used by HSE for signaling channel status
+ * as busy after a service request has been sent, until the HSE reply is ready.
+ *
+ * Return: true for channel available, false for invalid index or channel busy
+ */
+static bool hse_mu_channel_available(u8 channel)
+{
+	u32 fsrval, tsrval, rsrval;
+
+	if (unlikely(channel >= HSE_NUM_CHANNELS))
+		return false;
+
+	fsrval = ioread32(&regs->fsr) & BIT(channel);
+	tsrval = ioread32(&regs->tsr) & BIT(channel);
+	rsrval = ioread32(&regs->rsr) & BIT(channel);
+
+	if (fsrval || !tsrval || rsrval)
+		return false;
+
+	return true;
+}
+
+/**
+ * hse_mu_msg_pending - check if a service request response is pending
+ * @channel: channel index
+ *
+ * Return: true for response ready, false otherwise
+ */
+bool hse_mu_msg_pending(u8 channel)
+{
+	u32 rsrval;
+
+	if (unlikely(channel >= HSE_NUM_CHANNELS))
+		return false;
+
+	rsrval = ioread32(&regs->rsr) & BIT(channel);
+	if (!rsrval)
+		return false;
+
+	return true;
+}
+
+/**
+ * hse_mu_msg_send - send a message over MU (non-blocking)
+ * @channel: channel index
+ * @msg: input message
+ *
+ * Return: 0 on success, -EINVAL for invalid parameter, -ECHRNG for channel
+ *         index out of range, -EBUSY for selected channel busy
+ */
+int hse_mu_msg_send(u8 channel, u32 msg)
+{
+	if (unlikely(channel >= HSE_NUM_CHANNELS)) {
+		printf("%s: channel %d outside range\n", __func__, channel);
+		return -ECHRNG;
+	}
+
+	if (unlikely(!hse_mu_channel_available(channel))) {
+		printf("%s: channel %d busy\n", __func__, channel);
+		return -EBUSY;
+	}
+
+	iowrite32(msg, &regs->tr[channel]);
+
+	return 0;
+}
+
+/**
+ * hse_mu_msg_recv - read a message received over MU (non-blocking)
+ * @channel: channel index
+ * @msg: output message
+ *
+ * Return: 0 on success, -EINVAL for invalid parameter, -ECHRNG for channel
+ *         index out of range, -ENOMSG for no reply pending on selected channel
+ */
+int hse_mu_msg_recv(u8 channel, u32 *msg)
+{
+	if (unlikely(!msg)) {
+		printf("%s: msg buff pointer is null\n", __func__);
+		return -EINVAL;
+	}
+
+	if (unlikely(channel >= HSE_NUM_CHANNELS)) {
+		printf("%s: channel %d outside range\n", __func__, channel);
+		return -ECHRNG;
+	}
+
+	if (unlikely(!hse_mu_msg_pending(channel)))
+		return -ENOMSG;
+
+	*msg = ioread32(&regs->rr[channel]);
+
+	return 0;
+}
+
+/**
+ * hse_send_recv - send a message and wait for reply
+ * @channel: channel index
+ * @send_buf: input message
+ * @recv_buf: ptr to store output message
+ *
+ * Return: 0 on success, error code otherwise
+ */
+int hse_send_recv(u8 channel, u32 send_buf, u32 *recv_buf)
+{
+	int ret;
+
+	ret = hse_mu_msg_send(channel, send_buf);
+	if (ret)
+		return CMD_RET_FAILURE;
+
+	do {
+		ret = hse_mu_msg_recv(channel, recv_buf);
+	} while (ret == -ENOMSG);
+	if (ret)
+		return CMD_RET_FAILURE;
+
+	return hse_err_decode(recv_buf);
+}
diff --git a/include/hse/hse_abi.h b/include/hse/hse_abi.h
new file mode 100644
index 00000000..1233e4b8
--- /dev/null
+++ b/include/hse/hse_abi.h
@@ -0,0 +1,483 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * HSE ABI for secure boot in u-boot
+ *
+ * Copyright 2020-2022 NXP
+ */
+
+#ifndef HSE_ABI_H
+#define HSE_ABI_H
+
+#include <common.h>
+#include <mmc.h>
+#include <uuid.h>
+
+#define BYTES_TO_BITS(x)	((x) * 8u)
+
+#define MODULUS_OFFSET  0x21u
+#define MODULUS_SIZE    0x100u
+#define EXPONENT_OFFSET 0x123u
+#define EXPONENT_SIZE   0x3u
+
+#define HSE_SRV_RSP_OK            0x55A5AA33ul
+#define HSE_SRV_RSP_VERIFY_FAILED 0x55A5A164ul
+#define HSE_SRV_RSP_INVALID_ADDR  0x55A5A26Aul
+#define HSE_SRV_RSP_INVALID_PARAM 0x55A5A399ul
+#define HSE_SRV_RSP_NOT_ALLOWED   0xAA55A21Cul
+#define HSE_SRV_RSP_KEY_INVALID   0xA5AA52B4ul
+
+#define HSE_SYS_IMG_MAX_SIZE 0xC000u
+#define HSE_FIP_AUTH_LEN     0x100u
+#define HSE_AUTH_TAG_OFFSET  0x200u
+
+#define HSE_IVT_BLK      8
+
+#define HSE_EXT_FLASH_SD   2u
+#define HSE_EXT_FLASH_PAGE 512u
+
+#define HSE_CHANNEL_ADMIN   0u
+#define HSE_CHANNEL_GENERAL 1u
+
+#define HSE_STATUS_INIT_OK        BIT(8)
+#define HSE_STATUS_PRIMARY_SYSIMG BIT(14)
+#define HSE_IVT_BOOTSEQ_BIT       BIT(3)
+
+#define HSE_SRV_ID_SET_ATTR                 0x00000001ul
+#define HSE_SRV_ID_PUBLISH_SYS_IMAGE        0x00000011ul
+#define HSE_SRV_ID_FORMAT_KEY_CATALOGS      0x00000101ul
+#define HSE_SRV_ID_IMPORT_KEY               0x00000104ul
+#define HSE_SRV_ID_SMR_ENTRY_INSTALL        0x00000501ul
+#define HSE_SRV_ID_CORE_RESET_ENTRY_INSTALL 0x00000503ul
+
+#define HSE_ACCESS_MODE_ONE_PASS 0u
+
+#define HSE_APP_CORE3 3u /* A53_0 */
+
+#define HSE_PUBLISH_UPDATED_DATA_SET BIT(0)
+#define HSE_PUBLISH_ALL_DATA_SETS    BIT(1)
+
+#define HSE_SGT_OPTION_NONE 0u
+
+#define HSE_SMR_CFG_FLAG_SD_FLASH     0x2u
+#define HSE_SMR_CFG_FLAG_INSTALL_AUTH BIT(2)
+#define HSE_SMR_ENTRY_1               BIT(1)
+
+#define HSE_CR_SANCTION_KEEP_CORE_IN_RESET 0x7455u
+#define HSE_CR_AUTO_START                  0x35A5u
+
+#define HSE_MU_ACTIVATED      0xA5u
+#define HSE_MU_DEACTIVATED    0x5Au
+#define HSE_MU_CONFIG_ATTR_ID 20u
+
+#define HSE_SIGN_RSASSA_PKCS1_V15 0x93u
+#define HSE_HASH_ALGO_SHA_1       2u
+
+#define HSE_INVALID_KEY_HANDLE              0xFFFFFFFFul
+#define HSE_BOOT_KEY_HANDLE                 0x010700u
+#define HSE_SMR_DECRYPT_KEY_HANDLE_NOT_USED 0ul
+
+#define HSE_MU0_MASK    BIT(0)
+#define HSE_MU1_MASK    BIT(1)
+#define HSE_MU2_MASK    BIT(2)
+#define HSE_MU3_MASK    BIT(3)
+#define HSE_ALL_MU_MASK (HSE_MU0_MASK | HSE_MU1_MASK | \
+			 HSE_MU2_MASK | HSE_MU3_MASK)
+
+#define HSE_KF_USAGE_VERIFY BIT(3)
+
+#define HSE_KEY_OWNER_ANY  0u
+#define HSE_KEY_OWNER_CUST 1u
+#define HSE_KEY_OWNER_OEM  2u
+
+#define HSE_KEY_TYPE_AES           0x12u
+#define HSE_KEY_TYPE_HMAC          0x20u
+#define HSE_KEY_TYPE_SHARED_SECRET 0x30u
+#define HSE_KEY_TYPE_ECC_PAIR      0x87u
+#define HSE_KEY_TYPE_ECC_PUB       0x88u
+#define HSE_KEY_TYPE_ECC_PUB_EXT   0x89u
+#define HSE_KEY_TYPE_RSA_PAIR      0x97u
+#define HSE_KEY_TYPE_RSA_PUB       0x98u
+#define HSE_KEY_TYPE_RSA_PUB_EXT   0x99u
+
+#define HSE_KEY128_BITS  128u
+#define HSE_KEY256_BITS  256u
+#define HSE_KEY512_BITS  512u
+#define HSE_KEY521_BITS  521u
+#define HSE_KEY638_BITS  638u
+#define HSE_KEY1024_BITS 1024u
+#define HSE_KEY2048_BITS 2048u
+#define HSE_KEY4096_BITS 4096u
+
+/* see include/mmc.h */
+struct mmc *hse_init_mmc_device(int dev, bool force_init);
+int hse_mmc_read(void *addr, u32 blk, u32 cnt);
+int hse_mmc_write(void *addr, u32 blk, u32 cnt);
+
+/**
+ * struct fip_toc_header - FIP ToC header
+ * @name: fip name/signature, fixed
+ * @serial_number: fip serial number, fixed
+ * @flags: flags associated with the data
+ */
+struct fip_toc_header {
+	u32 name;
+	u32 serial_number;
+	u64 flags;
+};
+
+/**
+ * struct fip_toc_entry - FIP ToC entry
+ * @uuid: ToC entry unique ID
+ * @offset: offset of entry in FIP
+ * @size: size of entry
+ * @flags: flags associated with the data
+ */
+struct fip_toc_entry {
+	struct uuid uuid;
+	u64 offset;
+	u64 size;
+	u64 flags;
+};
+
+/**
+ * struct app_boot_hdr - app load, entry and size info
+ * @header: start of application image
+ * @ram_load: address at which to load app code
+ * @ram_entry: address at which to jump execution
+ * @code_len: length of subsequent code
+ */
+struct app_boot_hdr {
+	u32 header;
+	u32 ram_load;
+	u32 ram_entry;
+	u32 code_len;
+};
+
+/**
+ * struct ivt - ivt held in flash
+ * @header: header showing the start of IVT
+ * @dcd_self_test: ptr to cfg data used for BIST
+ * @dcd_self_test_backup: ptr to backup cfg data used for BIST
+ * @dcd: ptr to DCD cfg data
+ * @dcd_backup: ptr to backup DCD cfg data
+ * @hse_fw: ptr to HSE-H firmware in flash
+ * @hse_fw_backup: ptr to backup HSE-H fw in flash
+ * @app_boot: ptr to application boot code in flash
+ * @app_boot_backup: ptr to backup application boot code in flash
+ * @boot_cfg: cfg data used to select boot configuration
+ * @lc_cfg: cfg data used for advancing lifecycle
+ * @sys_img: ptr to SYS-IMG file in flash
+ * @sys_img_backup: ptr to SYS-IMG backup file in flash
+ * @sys_img_ext_flash_type: cfg data to select flash type for ASB
+ * @sys_img_flash_page_size: cfg data to select flash erasable page size
+ * @app_bsb_ext_flash_type: cfg data to select flash type for BSB
+ * @gmac: hash of data from IVT
+ */
+struct ivt {
+	u32 ivt_header;
+	u8 reserved1[4];
+	u32 dcd_self_test;
+	u32 dcd_self_test_backup;
+	u32 dcd;
+	u32 dcd_backup;
+	u32 hse_fw;
+	u32 hse_fw_backup;
+	u32 app_boot;
+	u32 app_boot_backup;
+	u32 boot_cfg;
+	u32 lc_cfg;
+	u8 reserved2[4];
+	u32 sys_img;
+	u32 sys_img_backup;
+	u32 sys_img_ext_flash_type;
+	u32 sys_img_flash_page_size;
+	u32 app_bsb_ext_flash_type;
+	u8 reserved3[168];
+	u32 gmac[4];
+	/* pad to block size - 512 bytes */
+	u8 reserved4[256];
+} __packed;
+
+/**
+ * struct hse_key_group_cfg_entry - key group entry in key catalog
+ * @mu_mask: mu instance for the key group
+ * @group_owner: key group owner
+ * @key_type: group key type
+ * @num_key_slots: max number of keys in slot
+ * @max_key_bit_len: max bit length of keys in group
+ */
+struct hse_key_group_cfg_entry {
+	u8 mu_mask;
+	u8 group_owner;
+	u8 key_type;
+	u8 num_key_slots;
+	u16 max_key_bit_len;
+	u8 reserved[2];
+} __packed;
+
+/**
+ * struct hse_format_key_catalogs_srv - key catalog format service
+ * @nvm_key_catalog_cfg_addr: ptr to NVM key catalog
+ * @ram_key_catalog_cfg_addr: ptr to RAM key catalog
+ */
+struct hse_format_key_catalogs_srv {
+	u64 nvm_key_catalog_cfg_addr;
+	u64 ram_key_catalog_cfg_addr;
+} __packed;
+
+/**
+ * struct hse_key_info - key properties
+ * @key_flags: define key usage
+ * @key_bit_len: for RSA, bit length of public modulus n
+ * @key_counter: 28 bit counter to prevent rollback attacks on key
+ * @smr_flags: which SMR must be checked before using key; 0 is unused
+ * @key_type: key type
+ * @pub_exponent_size: size in bytes of RSA public exponent e
+ */
+struct hse_key_info {
+	u16 key_flags;
+	u16 key_bit_len;
+	u32 key_counter;
+	u32 smr_flags;
+	u8 key_type;
+	u8 pub_exponent_size;
+	u8 reserved[2];
+} __packed;
+
+/**
+ * struct hse_import_key_srv - key import service
+ * @key_handle: specified slot in which to add/update the key
+ * @key_info_addr: ptr to struct hse_key_info
+ * @key_addr[2]: ptr to key values
+ *               [0] - RSA public modulus n (big-endian)
+ *               [1] - RSA public exponent e (big-endian)
+ * @key_len[2]: length in bytes for above key values
+ * @cipher_key: decryption key handle, set to HSE_INVALID_KEY_HANDLE
+ * @auth_key: auth key handle, set to HSE_INVALID_KEY_HANDLE
+ */
+struct hse_import_key_srv {
+	u32 key_handle;
+	u64 key_info_addr;
+	u64 key_addr[3];
+	u16 key_len[3];
+	u8 reserved1[2];
+	u32 cipher_key;
+	u8 reserved2[48];
+	u32 auth_key;
+	u8 reserved3[48];
+} __packed;
+
+/**
+ * struct hse_rsa_pkcs1v15_scheme - parameters for RSASSA_PKCS1_V15
+ * @hash_algo: specify hash algorithm
+ *             must not be HSE_HASH_ALGO_NULL or HSE_HASH_ALGO_MD5
+ */
+struct hse_rsa_pkcs1v15_scheme {
+	u8 hash_algo;
+	u8 reserved[3];
+} __packed;
+
+/**
+ * struct hse_sign_scheme - parameters for signature generate/verify
+ * @sign_scheme: signature scheme
+ * @sch: RSASSA_PKCS1_V15 signature scheme parameters
+ */
+struct hse_sign_scheme {
+	u8 sign_scheme;
+	u8 reserved1[3];
+	struct hse_rsa_pkcs1v15_scheme sch;
+	u8 reserved2[8];
+} __packed;
+
+/**
+ * struct hse_smr_entry - SMR entry
+ * @smr_src: ptr to SMR load location in flash
+ * @smr_dst_addr: ptr to write location after authentication
+ * @smr_size: size in bytes of SMR to be loaded
+ * @config_flags: config flags for SMR entry
+ * @check_period: required by hse, must be 0
+ * @key_handle: key from key catalog used to authenticate SMR
+ * @sign_sch: auth scheme used to verify the SMR
+ * @auth_tag: location of SMR signature in flash
+ * @decrypt_key_handle: specifies parameters for smr decryption
+ * @version_offset: unused, must be set to 0
+ */
+struct hse_smr_entry {
+	u32 smr_src;
+	u64 smr_dst_addr;
+	u32 smr_size;
+	u8 config_flags;
+	u8 reserved1[3];
+	u32 check_period;
+	u32 key_handle;
+	struct hse_sign_scheme sign_sch;
+	u32 auth_tag;
+	u8 reserved2[4];
+	u32 decrypt_key_handle;
+	u8 reserved3[12];
+	u32 version_offset;
+} __packed;
+
+/**
+ * struct hse_cr_entry - core reset entry
+ * @core_id: core to be un-gated once SMR authentication is successful
+ * @cr_sanction: sanction to apply if SMR authentication fails
+ * @preboot_smr_map: smr entries which need to be verified before
+ *                   booting to ungate core
+ * @pass_reset: first instruction to jump to if verification is successful
+ * @start_option: specifies if the core is automatically released from
+ *                reset or not
+ */
+struct hse_cr_entry {
+	u8 core_id;
+	u8 reserved1[1];
+	u16 cr_sanction;
+	u32 preboot_smr_map;
+	u32 pass_reset;
+	u8 reserved2[12];
+	u16 start_option;
+	u8 reserved3[6];
+} __packed;
+
+/**
+ * struct hse_smr_install_srv - SMR installation service
+ * @access_mode: specify access mode
+ * @entry_index: specify SMR entry index to install
+ * @smr_entry_addr: ptr to struct hse_smr_entry
+ * @smr_data_addr: ptr to SMR data to install
+ * @smr_data_len: length of SMR data to install
+ * @smr_auth_tag_addr: ptr to SMR data authentication tag to verify
+ * @smr_auth_tag_len: length of SMR data authentication tag
+ */
+struct hse_smr_install_srv {
+	u8 access_mode;
+	u8 entry_index;
+	u8 reserved1[2];
+	u64 smr_entry_addr;
+	u64 smr_data_addr;
+	u32 smr_data_len;
+	u64 smr_auth_tag_addr;
+	u8 reserved2[8];
+	u16 smr_auth_tag_len;
+	u8 reserved3[18];
+} __packed;
+
+/**
+ * struct hse_cr_install_srv - Core Reset installation service
+ * @cr_entry_index: specify CR entry index to install
+ * @cr_entry_addr: ptr to struct hse_cr_entry
+ */
+struct hse_cr_install_srv {
+	u8 cr_entry_index;
+	u8 reserved[3];
+	u64 cr_entry_addr;
+} __packed;
+
+/**
+ * struct hse_publish_sys_img_srv - SYS-IMG publish service
+ * @publish_options: specify which data sets to publish in SYS-IMG
+ * @publish_offset_addr: ptr to store SYS-IMG offset in flash, unused
+ * @buff_length_addr: as input, specify length of output buffer
+ *                    as output, number of bytes written by HSE into buffer
+ * @buff_addr: ptr to buffer in which to store SYS-IMG
+ */
+struct hse_publish_sys_img_srv {
+	u8 publish_options;
+	u8 reserved1[3];
+	u64 publish_offset_addr;
+	u64 buff_length_addr;
+	u64 buff_addr;
+} __packed;
+
+/**
+ * struct hse_mu_instance_config - configure a MU interface
+ * @mu_config: specify MU state; MU0 cannot be deactivated
+ * @xrdc_domain_id: domain id to acces host interface memory chunk
+ * @shared_mem_chunk_size: which chunk of host interface memory to reserve
+ */
+struct hse_mu_instance_config {
+	u8 mu_config;
+	u8 xrdc_domain_id;
+	u16 shared_mem_chunk_size;
+	u8 reserved[60];
+} __packed;
+
+/**
+ * struct hse_mu_config - configure all MU interfaces
+ * @mu_instances: contains configuration for all MU interfaces
+ */
+struct hse_mu_config {
+	struct hse_mu_instance_config mu_instances[4];
+} __packed;
+
+/**
+ * struct hse_getset_attr_srv - get attribute
+ * @attr_id: attribute ID
+ * @attr_len: attribute length, in bytes
+ * @attr: DMA address of the attribute
+ */
+struct hse_getset_attr_srv {
+	u16 attr_id;
+	u8 reserved[2];
+	u32 attr_len;
+	u64 p_attr;
+} __packed;
+
+/**
+ * struct hse_srv_desc - HSE service descriptor
+ * @srv_id: specify service for HSE to execute
+ * @union: specify service parameters
+ */
+struct hse_srv_desc {
+	u32 srv_id;
+	u8 reserved[4];
+	union {
+		struct hse_getset_attr_srv getset_attr_req;
+		struct hse_format_key_catalogs_srv format_catalogs_req;
+		struct hse_import_key_srv import_key_req;
+		struct hse_cr_install_srv cr_install_req;
+		struct hse_smr_install_srv smr_install_req;
+		struct hse_publish_sys_img_srv publish_sys_img_req;
+	};
+} __packed;
+
+/**
+ * struct hse_private - hse required data, stored at start of ddr
+ * @ivt: ivt stored for modifications required for secboot
+ * @app_boot_hdr: application load, entry and size data
+ * @srv_desc: service descriptor
+ * @key_info: key data for insertion into catalog
+ * @cr_entry: core reset entry data
+ * @smr_entry: secure memory region data
+ * @mu_config: mu configuration data
+ * @rsa_pubkey: contents of public key file, in DER format
+ * @rsa_modulus: rsa public key modulus, extracted from file
+ * @rsa_exponent: rsa public key exponent, extracted from file
+ * @fip_sign: fip signature in ddr
+ * @sys_img: hse-generated system image
+ * @sys_img_len: system image length
+ * @publish_offset: offset at which to write the updated sys_img
+ * @nvm_catalog: nvm key catalog
+ * @ram_catalog: ram key catalog
+ */
+struct hse_private {
+	struct ivt ivt;
+	struct app_boot_hdr app_boot_hdr;
+	struct hse_srv_desc srv_desc;
+	struct hse_key_info key_info;
+	struct hse_cr_entry cr_entry;
+	struct hse_smr_entry smr_entry;
+	struct hse_mu_config mu_config;
+	u8 rsa_pubkey[512];
+	u8 rsa_modulus[256];
+	u8 rsa_exponent[3];
+	u8 reserved;
+	u8 fip_signature[256];
+	u8 sys_img[HSE_SYS_IMG_MAX_SIZE];
+	u32 sys_img_len;
+	u32 publish_offset;
+	struct hse_key_group_cfg_entry nvm_catalog[20];
+	struct hse_key_group_cfg_entry ram_catalog[11];
+};
+
+#endif /* HSE_ABI_H */
diff --git a/include/hse/hse_mu.h b/include/hse/hse_mu.h
new file mode 100644
index 00000000..7619fe36
--- /dev/null
+++ b/include/hse/hse_mu.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * HSE MU interface for secure boot in u-boot
+ *
+ * Copyright 2020 NXP
+ */
+
+#ifndef HSE_MU_H
+#define HSE_MU_H
+
+#define HSE_NUM_CHANNELS    16u /* number of available service channels */
+
+u16 hse_mu_check_status(void);
+bool hse_mu_msg_pending(u8 channel);
+
+int hse_mu_msg_send(u8 channel, u32 msg);
+int hse_mu_msg_recv(u8 channel, u32 *msg);
+int hse_send_recv(u8 channel, u32 send_buf, u32 *recv_buf);
+
+#endif /* HSE_MU_H */
-- 
2.34.1

